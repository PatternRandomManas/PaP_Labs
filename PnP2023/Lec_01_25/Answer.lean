import Mathlib

/-!
# Inductive Types

The main way of introducing new types in Lean is through inductive types. An inductive type is a type
which is specified by saying how to construct terms of that type. Concretely, we specify the types of 
a set of `constructors` all of which have _final codomain_ the type being constructed.

When an inductive type is defined, Lean automatically generates a _recursor_ for that type, which allows defining by cases, matching, and induction on terms of that type.
-/

namespace Waffle

/-!
## Enumerated Types

Enumerated types are a special case of inductive types where the constructors have no arguments. We simply list the terms of that type.
-/

/-- 
An enumerated type for the answers to a yes/no question. 
-/
inductive Answer where
  | yes : Answer
  | no : Answer
  | maybe : Answer
deriving Repr, Inhabited, DecidableEq

#check Answer -- Type
#check Answer.yes -- Answer
#eval Answer.yes -- Waffle.Answer.yes

#eval (default : Answer)

/-- A function defined by cases which disagrees with the given answer. -/
def disagree: Answer → Answer
  | Answer.yes => Answer.no
  | Answer.no => Answer.yes
  | Answer.maybe => Answer.maybe

#eval disagree Answer.yes -- Waffle.Answer.no
#reduce disagree
#check Answer.rec

/--
If an answer is equal to its disagreement, then it must be `maybe`.
-/
theorem disagree_eq_maybe(ans: Answer) : 
  (disagree ans) = ans → ans = Answer.maybe :=
    by
      cases ans <;> simp [disagree] 

#reduce disagree -- fun x => Answer.rec Answer.no Answer.yes Answer.maybe x
#check @Answer.rec -- {motive : Answer → Sort u_1} → motive Answer.yes → motive Answer.no → motive Answer.maybe → (t : Answer) → motive t

#check @Answer.rec (motive := fun _ => String) -- String → String → String → Answer → String


end Waffle


/-!
## Structures

The definition is rewritten by Lean in terms of the `rec` function, which is automatically generated by Lean for each inductive type. The `rec` function is a _recursor_ for the type, which allows defining by cases, matching, and induction on terms of that type.

```lean
#reduce disagree -- fun x => Answer.rec Answer.no Answer.yes Answer.maybe x
#check @Answer.rec -- {motive : Answer → Sort u_1} → motive Answer.yes → motive Answer.no → motive Answer.maybe → (t : Answer) → motive t

```

-/

namespace Explained

/-!
Another simple kind of inductive type is a `Structure`, whose terms correspond to values of specified fields of given types.
-/

/-- A structure for answers with explanations -/
structure Answer where
  agree : Bool
  explanation: String

/-!
An element of the type can be constructed using special syntax which is similar to a tuple but with left and right angle brackets instead of parentheses. 

```lean
example : Answer := ⟨true, "I agree"⟩
```
-/

example : Answer := ⟨true, "I agree"⟩
example : Answer := 
    Answer.mk false "it would be crazy if it was true"

/-!
When a structure is defined, a constructor named `mk` is automatically generated. The constructor is a function which takes the arguments of the structure in the order they are declared and returns a term of the structure type. 

Further, projections onto each of the fields are defined as functions named after the field. As with any induction type, a recursor is automatically generated for the structure.

```lean
#check Answer -- Type
#check Answer.agree -- Answer → Bool 
#check Answer.explanation -- Answer → String
#check Answer.mk -- Bool → String → Answer
#check Answer.rec -- {motive : Answer → Sort u} → ((agree : Bool) → (explanation : String) → motive { agree := agree, explanation := explanation }) → (t : Answer) → motive t
```
-/
#check Answer -- Type
#check Answer.agree -- Answer → Bool 
#check Answer.explanation -- Answer → String
#check Answer.mk -- Bool → String → Answer
#check Answer.rec -- {motive : Answer → Sort u} → ((agree : Bool) → (explanation : String) → motive { agree := agree, explanation := explanation }) → (t : Answer) → motive t

end Explained

namespace VerboseExplained

inductive Answer where
| mk : Bool → String → Answer

def Answer.agree : Answer → Bool
| ⟨agree, _⟩ => agree

def Answer.explanation : Answer → String :=
  fun ⟨_, exp⟩ ↦ exp

end VerboseExplained

namespace LongWinded

inductive Answer where
| yes : Answer
| no : Answer
| maybe : Answer
| explained : String → Answer → Answer
deriving Inhabited, DecidableEq, Repr

def egAnswer : Answer := Answer.explained "I agree" Answer.yes

def egAnswerLong : Answer :=
  Answer.explained "Let me play the devil's advocate" (
    Answer.explained "This is silly" Answer.no
  )

def egAnswerCharlieBrown : Answer :=
  Answer.explained "Maybe" <|
    Answer.explained  "Maybe not" Answer.maybe

#eval egAnswerLong

def disagree  : Answer → Answer
| Answer.yes => Answer.no
| Answer.no => Answer.yes
| Answer.maybe => Answer.maybe
| Answer.explained exp ans => 
    Answer.explained ("It would be silly to say `"++ exp ++"'") (disagree ans)

#eval disagree egAnswerLong

def explanation : Answer → String
| Answer.yes => "I agree"
| Answer.no => "I disagree"
| Answer.maybe => "I don't know"
| Answer.explained exp ans => explanation ans  ++ " because " ++ exp

#eval explanation egAnswerLong

#check @Answer.rec (motive := fun _ => String) -- String → String → String → (String → Answer → String → String) → Answer → String

end LongWinded

namespace Waffle

inductive Answer.le : Answer → Answer →  Prop where
| no_le (ans: Answer) : Answer.le Answer.no ans
| le_yes (ans: Answer) : 
    Answer.le ans Answer.yes
| refl (ans : Answer) : 
    Answer.le ans ans


instance : LE Answer := ⟨Answer.le⟩

#check Answer.no ≤  Answer.yes -- Answer.no ≤ Answer.yes : Prop

theorem le_trans (a b c : Answer) : 
  a ≤  b → b ≤  c → a ≤  c :=
  by
    intro h₁ h₂
    cases c₁:h₁
    case no_le => 
      apply Answer.le.no_le
    case le_yes => 
      cases c₂:h₂
      case le_yes => apply Answer.le.le_yes
      case refl => assumption
    case refl => assumption


end Waffle

namespace PropAnswer

inductive Answer : Prop where
  | yes : Answer
  | no : Answer
  | maybe : Answer

#check Answer -- PropAnswer.Answer : Prop

/-!
```lean
def generous : Answer → Bool
  | Answer.yes => true
  | Answer.no => false
  | Answer.maybe => true
```
gives error message
```lean
tactic 'cases' failed, nested error:
tactic 'induction' failed, recursor 'PropAnswer.Answer.casesOn' can only eliminate into Prop
motive: Answer → Sort ?u.9737
h_1: Unit → motive Answer.yes
h_2: Unit → motive Answer.no
h_3: Unit → motive Answer.maybe
⊢ motive x✝
 after processing
  _
the dependent pattern matcher can solve the following kinds of equations
- <var> = <term> and <term> = <var>
- <term> = <term> where the terms are definitionally equal
- <constructor> = <constructor>, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil
```
-/

#check Answer.rec /- PropAnswer.Answer.rec {motive : Answer → Prop} (yes : motive Answer.yes) (no : motive Answer.no)
  (maybe : motive Answer.maybe) (t : Answer) : motive t
-/


end PropAnswer